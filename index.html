<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 네트워크 그래프</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #000;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas {
            display: block;
        }

        .control-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 250px;
        }

        .control-panel h4 {
            margin-top: 0;
            margin-bottom: 10px;
        }

        .control-panel button {
            margin: 3px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-size: 11px;
        }

        .control-panel button:hover {
            background-color: #0056b3;
        }

        .control-panel button.active {
            background-color: #28a745;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 300px;
            font-size: 12px;
        }

        .file-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }

        .file-controls input[type="file"] {
            font-size: 10px;
            margin: 5px 0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1002;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 400px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-height: 70vh;
            overflow-y: auto;
        }

        .modal input, .modal select, .modal textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .modal textarea {
            height: 80px;
            resize: vertical;
        }

        .modal button {
            margin: 5px;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .modal .confirm {
            background-color: #4CAF50;
            color: white;
        }

        .modal .cancel {
            background-color: #f44336;
            color: white;
        }

        .formula-help {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }

        .node-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 5px;
            margin: 5px 0;
        }

        .node-item {
            padding: 2px 5px;
            font-size: 11px;
            background-color: #f9f9f9;
            margin: 2px 0;
            border-radius: 3px;
        }

        .calculation-log {
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
        }

        .position-controls {
            display: none;
        }

        .auto-layout-info {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 3px;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        .button-row button {
            flex: 1;
            min-width: 70px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div class="control-panel">
            <h4>컨트롤</h4>
            <div class="button-row">
                <button onclick="addNode()">노드 추가</button>
                <button id="connectBtn" onclick="connectMode()">연결 모드</button>
            </div>
            <div class="button-row">
                <button onclick="calculateValues()">값 계산</button>
                <button onclick="autoLayout()">자동 배치</button>
            </div>
            <div class="button-row">
                <button onclick="sphereLayout()">구형 배치</button>
                <button id="autoRotateBtn" onclick="autoRotate()">자동 회전</button>
            </div>
            <div class="button-row">
                <button onclick="resetGraph()">초기화</button>
            </div>
            
            <div class="file-controls">
                <h5 style="margin: 5px 0;">파일</h5>
                <div class="button-row">
                    <button onclick="saveGraph()">저장</button>
                    <button onclick="document.getElementById('fileInput').click()">불러오기</button>
                </div>
                <input type="file" id="fileInput" accept=".json" style="display: none;" onchange="loadGraph(this)">
                <div class="button-row" style="margin-top: 5px;">
                    <button onclick="exportToImage()">이미지 저장</button>
                </div>
            </div>
            
            <div class="auto-layout-info">
                노드는 연결 관계에 따라 자동으로 배치됩니다
            </div>
        </div>

        <div class="info-panel">
            <h4>선택된 노드</h4>
            <div id="selectedNodeInfo">노드를 선택하세요</div>
            <div id="calculationLog" class="calculation-log"></div>
        </div>

        <div id="nodeModal" class="modal">
            <div class="modal-content">
                <h3>노드 편집</h3>
                <label>노드 이름:</label>
                <input type="text" id="nodeLabel" placeholder="노드 이름">
                
                <label>노드 타입:</label>
                <select id="nodeType" onchange="onNodeTypeChange()">
                    <option value="input">입력 노드</option>
                    <option value="calculated">계산 노드</option>
                    <option value="target">목적 노드</option>
                </select>
                
                <div id="inputValueDiv">
                    <label>값:</label>
                    <input type="number" id="nodeValue" placeholder="값" step="0.01">
                </div>
                
                <div id="formulaDiv" style="display: none;">
                    <label>계산식:</label>
                    <textarea id="nodeFormula" placeholder="예: a * 0.5 + b * 0.3"></textarea>
                    <div class="formula-help">
                        사용 가능한 변수: 연결된 입력 노드들의 ID (a, b, c, ...)
                        <br>연산자: +, -, *, /, ^(거듭제곱), sqrt(), sin(), cos(), log() 등
                    </div>
                    <div class="node-list">
                        <strong>사용 가능한 변수:</strong>
                        <div id="availableVariables"></div>
                    </div>
                </div>
                
                <div class="position-controls">
                    <label>위치 (자동 배치 사용 시 무시됨):</label>
                    <input type="number" id="nodeX" placeholder="X" step="1">
                    <input type="number" id="nodeY" placeholder="Y" step="1">
                    <input type="number" id="nodeZ" placeholder="Z" step="1">
                </div>
                
                <br><br>
                <button class="confirm" onclick="saveNode()">확인</button>
                <button class="cancel" onclick="closeModal()">취소</button>
                <button onclick="deleteCurrentNode()" style="background-color: #ff6b6b; color: white;">삭제</button>
            </div>
        </div>

        <div id="linkModal" class="modal">
            <div class="modal-content">
                <h3>연결 편집</h3>
                <label>가중치:</label>
                <input type="number" id="linkWeight" placeholder="가중치" step="0.01" value="1">
                <br><br>
                <button class="confirm" onclick="saveLink()">확인</button>
                <button class="cancel" onclick="closeModal()">취소</button>
                <button onclick="deleteCurrentLink()" style="background-color: #ff6b6b; color: white;">삭제</button>
            </div>
        </div>
    </div>

    <script>
        class NetworkGraph3D {
            constructor() {
                this.nodes = [];
                this.links = [];
                this.selectedNode = null;
                this.selectedLink = null;
                this.connectingMode = false;
                this.connectingFrom = null;
                this.nodeIdCounter = 0;
                this.autoRotateEnabled = false;
                this.autoLayoutEnabled = true;

                this.nodeColors = {
                    input: 0x4CAF50,
                    calculated: 0xFF9800,
                    target: 0x2196F3
                };

                this.init3D();
                this.createSampleData();
                this.render();
                this.animate();
            }

            init3D() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a1a);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 200);

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'), 
                    antialias: true,
                    preserveDrawingBuffer: true // 이미지 저장을 위해 필요
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Controls
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 1.0);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(100, 100, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Raycaster for mouse interaction
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Event listeners
                this.renderer.domElement.addEventListener('click', (event) => this.onMouseClick(event));
                this.renderer.domElement.addEventListener('mousemove', (event) => this.onMouseMove(event));
                window.addEventListener('resize', () => this.onWindowResize());
                document.addEventListener('keydown', (event) => this.onKeyDown(event));

                // Groups for different object types
                this.nodeGroup = new THREE.Group();
                this.linkGroup = new THREE.Group();
                this.scene.add(this.nodeGroup);
                this.scene.add(this.linkGroup);
            }

            createSampleData() {
                // Sample nodes with auto layout
                this.addNodeData("입력A", 10, "input");
                this.addNodeData("입력B", 5, "input");
                this.addNodeData("계산1", 0, "calculated", "a * 0.7 + b * 0.3");
                this.addNodeData("목적1", 0, "target", "a * 2");
                this.addNodeData("최종", 0, "target", "a + 10");

                // Sample connections   
                this.addLinkData(0, 2, 1.0);
                this.addLinkData(1, 2, 1.0);
                this.addLinkData(2, 3, 1.0);
                this.addLinkData(3, 4, 1.0);

                // Apply auto layout
                this.applyAutoLayout();
            }

            addNodeData(label, value, type, formula = "") {
                const node = {
                    id: this.nodeIdCounter++,
                    label: label,
                    value: value,
                    type: type,
                    position: new THREE.Vector3(0, 0, 0),
                    formula: formula,
                    mesh: null,
                    textSprite: null
                };

                this.nodes.push(node);
                this.createNodeMesh(node);
                
                if (this.autoLayoutEnabled) {
                    this.applyAutoLayout();
                }
                
                return node;
            }

            addLinkData(sourceId, targetId, weight) {
                const sourceNode = this.nodes.find(n => n.id === sourceId);
                const targetNode = this.nodes.find(n => n.id === targetId);
                
                if (!sourceNode || !targetNode) return null;

                const link = {
                    source: sourceNode,
                    target: targetNode,
                    weight: weight,
                    mesh: null
                };

                this.links.push(link);
                this.createLinkMesh(link);
                
                if (this.autoLayoutEnabled) {
                    this.applyAutoLayout();
                }
                
                return link;
            }

            applyAutoLayout() {
                if (this.nodes.length === 0) return;

                // Simple hierarchical layout based on dependencies
                const levels = this.calculateNodeLevels();
                const maxLevel = Math.max(...levels.values());
                
                // Position nodes in levels
                levels.forEach((level, nodeId) => {
                    const node = this.nodes.find(n => n.id === nodeId);
                    if (!node) return;

                    const nodesAtLevel = Array.from(levels.entries()).filter(([_, l]) => l === level);
                    const indexAtLevel = nodesAtLevel.findIndex(([id, _]) => id === nodeId);
                    const totalAtLevel = nodesAtLevel.length;

                    // Horizontal positioning
                    const spacing = 80;
                    const startX = -(totalAtLevel - 1) * spacing / 2;
                    const x = startX + indexAtLevel * spacing;

                    // Vertical positioning (levels)
                    const levelSpacing = 100;
                    const y = (maxLevel - level) * levelSpacing - (maxLevel * levelSpacing / 2);

                    // Z positioning for visual depth
                    const z = (Math.random() - 0.5) * 40;

                    node.position.set(x, y, z);
                    this.updateNodeMesh(node);
                });

                // Update links
                this.links.forEach(link => this.updateLinkMesh(link));
            }

            calculateNodeLevels() {
                const levels = new Map();
                const visited = new Set();

                // Start with input nodes at level 0
                this.nodes.forEach(node => {
                    if (node.type === 'input') {
                        levels.set(node.id, 0);
                    }
                });

                // BFS to assign levels
                const queue = this.nodes.filter(n => n.type === 'input').map(n => n.id);
                
                while (queue.length > 0) {
                    const currentId = queue.shift();
                    if (visited.has(currentId)) continue;
                    visited.add(currentId);

                    const currentLevel = levels.get(currentId) || 0;
                    
                    // Find all nodes that depend on this node
                    const dependentLinks = this.links.filter(link => link.source.id === currentId);
                    
                    dependentLinks.forEach(link => {
                        const targetId = link.target.id;
                        const newLevel = currentLevel + 1;
                        
                        if (!levels.has(targetId) || levels.get(targetId) < newLevel) {
                            levels.set(targetId, newLevel);
                            queue.push(targetId);
                        }
                    });
                }

                // Handle orphaned nodes
                this.nodes.forEach(node => {
                    if (!levels.has(node.id)) {
                        levels.set(node.id, 0);
                    }
                });

                return levels;
            }

            createNodeMesh(node) {
                // Create sphere geometry
                const geometry = new THREE.SphereGeometry(8, 16, 16);
                const material = new THREE.MeshLambertMaterial({ 
                    color: this.nodeColors[node.type],
                    transparent: true,
                    opacity: 0.9
                });

                node.mesh = new THREE.Mesh(geometry, material);
                node.mesh.position.copy(node.position);
                node.mesh.castShadow = true;
                node.mesh.receiveShadow = true;
                node.mesh.userData = { type: 'node', node: node };

                // Create text sprite with improved visibility
                this.createTextSprite(node);

                this.nodeGroup.add(node.mesh);
                this.nodeGroup.add(node.textSprite);
            }

            createTextSprite(node) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 300;
                canvas.height = 120;
                
                // Clear canvas with white background
                context.fillStyle = 'rgba(255, 255, 255, 0.95)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add border
                context.strokeStyle = '#333333';
                context.lineWidth = 3;
                context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
                
                // Add inner shadow effect
                context.fillStyle = 'rgba(0, 0, 0, 0.1)';
                context.fillRect(8, 8, canvas.width - 16, canvas.height - 16);
                
                // Node label
                context.fillStyle = '#000000';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(node.label, canvas.width / 2, 35);
                
                // Node value with colored background
                const valueText = node.value.toFixed(3);
                const valueWidth = context.measureText(valueText).width + 20;
                
                // Value background
                context.fillStyle = this.getNodeTypeColor(node.type);
                context.fillRect((canvas.width - valueWidth) / 2, 55, valueWidth, 35);
                
                // Value text
                context.fillStyle = '#ffffff';
                context.font = 'bold 28px Arial';
                context.fillText(valueText, canvas.width / 2, 72);

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.01
                });
                
                if (node.textSprite) {
                    node.textSprite.material.dispose();
                    node.textSprite.material = spriteMaterial;
                } else {
                    node.textSprite = new THREE.Sprite(spriteMaterial);
                }
                
                node.textSprite.position.copy(node.position);
                node.textSprite.position.y += 25;
                node.textSprite.scale.set(40, 16, 1);
            }

            getNodeTypeColor(type) {
                switch(type) {
                    case 'input': return '#4CAF50';
                    case 'calculated': return '#FF9800';
                    case 'target': return '#2196F3';
                    default: return '#666666';
                }
            }

            createLinkMesh(link) {
                const points = [link.source.position, link.target.position];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x888888,
                    linewidth: Math.max(1, link.weight * 2),
                    transparent: true,
                    opacity: 0.8
                });

                link.mesh = new THREE.Line(geometry, material);
                link.mesh.userData = { type: 'link', link: link };

                // Arrow head
                const direction = new THREE.Vector3().subVectors(link.target.position, link.source.position).normalize();
                const arrowGeometry = new THREE.ConeGeometry(2, 6, 8);
                const arrowMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.8
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                
                const targetPos = link.target.position.clone();
                targetPos.add(direction.clone().multiplyScalar(-12));
                arrow.position.copy(targetPos);
                arrow.lookAt(link.target.position);

                link.arrow = arrow;
                this.linkGroup.add(link.mesh);
                this.linkGroup.add(arrow);
            }

            updateNodeMesh(node) {
                if (!node.mesh || !node.textSprite) return;

                // Update position
                node.mesh.position.copy(node.position);
                node.textSprite.position.copy(node.position);
                node.textSprite.position.y += 25;

                // Update color
                node.mesh.material.color.setHex(this.nodeColors[node.type]);

                // Update text
                this.createTextSprite(node);
            }

            updateLinkMesh(link) {
                if (!link.mesh) return;

                const points = [link.source.position, link.target.position];
                link.mesh.geometry.setFromPoints(points);
                link.mesh.geometry.needsUpdate = true;

                // Update arrow
                if (link.arrow) {
                    const direction = new THREE.Vector3().subVectors(link.target.position, link.source.position).normalize();
                    const targetPos = link.target.position.clone();
                    targetPos.add(direction.clone().multiplyScalar(-12));
                    link.arrow.position.copy(targetPos);
                    link.arrow.lookAt(link.target.position);
                }
            }

            // 저장/불러오기 기능
            exportData() {
                const data = {
                    nodes: this.nodes.map(node => ({
                        id: node.id,
                        label: node.label,
                        value: node.value,
                        type: node.type,
                        formula: node.formula,
                        position: {
                            x: node.position.x,
                            y: node.position.y,
                            z: node.position.z
                        }
                    })),
                    links: this.links.map(link => ({
                        sourceId: link.source.id,
                        targetId: link.target.id,
                        weight: link.weight
                    })),
                    nodeIdCounter: this.nodeIdCounter,
                    timestamp: new Date().toISOString()
                };
                return data;
            }

            importData(data) {
                try {
                    // Clear existing data
                    this.nodeGroup.clear();
                    this.linkGroup.clear();
                    this.nodes = [];
                    this.links = [];
                    this.selectedNode = null;
                    this.selectedLink = null;

                    // Restore counter
                    this.nodeIdCounter = data.nodeIdCounter || 0;

                    // Restore nodes
                    data.nodes.forEach(nodeData => {
                        const node = {
                            id: nodeData.id,
                            label: nodeData.label,
                            value: nodeData.value,
                            type: nodeData.type,
                            formula: nodeData.formula || '',
                            position: new THREE.Vector3(
                                nodeData.position.x,
                                nodeData.position.y,
                                nodeData.position.z
                            ),
                            mesh: null,
                            textSprite: null
                        };
                        this.nodes.push(node);
                        this.createNodeMesh(node);
                    });

                    // Restore links
                    data.links.forEach(linkData => {
                        const sourceNode = this.nodes.find(n => n.id === linkData.sourceId);
                        const targetNode = this.nodes.find(n => n.id === linkData.targetId);
                        
                        if (sourceNode && targetNode) {
                            const link = {
                                source: sourceNode,
                                target: targetNode,
                                weight: linkData.weight,
                                mesh: null
                            };
                            this.links.push(link);
                            this.createLinkMesh(link);
                        }
                    });

                    this.updateSelectedNodeInfo();
                    this.logCalculation('그래프를 성공적으로 불러왔습니다.');
                    return true;
                } catch (error) {
                    this.logCalculation(`불러오기 오류: ${error.message}`);
                    return false;
                }
            }

            onMouseClick(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.nodeGroup.children, true);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.type === 'node') {
                        const node = object.userData.node;
                        
                        if (this.connectingMode) {
                            this.handleConnection(node);
                        } else {
                            this.selectNode(node);
                        }
                    }
                }
            }

            onMouseMove(event) {
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            onKeyDown(event) {
                if (event.key === 'Escape') {
                    this.cancelConnecting();
                } else if (event.key === 'Delete' && this.selectedNode) {
                    this.deleteNode(this.selectedNode);
                }
            }

            selectNode(node) {
                // Reset previous selection
                if (this.selectedNode && this.selectedNode.mesh) {
                    this.selectedNode.mesh.material.emissive.setHex(0x000000);
                }

                this.selectedNode = node;
                if (node && node.mesh) {
                    node.mesh.material.emissive.setHex(0x444444);
                }

                this.updateSelectedNodeInfo();
            }

            updateSelectedNodeInfo() {
                const infoDiv = document.getElementById('selectedNodeInfo');
                if (this.selectedNode) {
                    const node = this.selectedNode;
                    const inputs = this.getNodeInputs(node);
                    const outputs = this.getNodeOutputs(node);
                    
                    infoDiv.innerHTML = `
                        <strong>${node.label}</strong><br>
                        타입: ${node.type}<br>
                        값: ${node.value.toFixed(3)}<br>
                        위치: (${node.position.x.toFixed(1)}, ${node.position.y.toFixed(1)}, ${node.position.z.toFixed(1)})<br>
                        ${node.formula ? `수식: ${node.formula}<br>` : ''}
                        입력: ${inputs.length}개<br>
                        출력: ${outputs.length}개<br>
                        <button onclick="editSelectedNode()" style="margin-top: 5px; padding: 3px 8px; font-size: 11px;">편집</button>
                    `;
                } else {
                    infoDiv.innerHTML = '노드를 선택하세요';
                }
            }

            handleConnection(targetNode) {
                if (!this.connectingFrom) {
                    this.connectingFrom = targetNode;
                    this.logCalculation(`연결 시작: ${targetNode.label}`);
                } else if (this.connectingFrom !== targetNode) {
                    // Check for cycles
                    if (this.wouldCreateCycle(this.connectingFrom, targetNode)) {
                        this.logCalculation('순환 참조가 발생할 수 있어 연결을 취소했습니다.');
                    } else {
                        this.addLinkData(this.connectingFrom.id, targetNode.id, 1.0);
                        this.logCalculation(`연결 완료: ${this.connectingFrom.label} -> ${targetNode.label}`);
                    }
                    this.cancelConnecting();
                }
            }

            wouldCreateCycle(sourceNode, targetNode) {
                const visited = new Set();
                const stack = [sourceNode];

                while (stack.length > 0) {
                    const current = stack.pop();
                    if (current === targetNode) return true;
                    if (visited.has(current.id)) continue;
                    
                    visited.add(current.id);
                    const outputs = this.getNodeOutputs(current);
                    outputs.forEach(link => stack.push(link.target));
                }

                return false;
            }

            cancelConnecting() {
                this.connectingMode = false;
                this.connectingFrom = null;
                document.body.style.cursor = 'default';
                document.getElementById('connectBtn').classList.remove('active');
            }

            getNodeInputs(node) {
                return this.links.filter(link => link.target === node);
            }

            getNodeOutputs(node) {
                return this.links.filter(link => link.source === node);
            }

            calculateValues() {
                this.logCalculation('=== 계산 시작 ===');
                
                const sorted = this.topologicalSort();
                
                for (const node of sorted) {
                    if (node.type === 'calculated' || node.type === 'target') {
                        this.calculateNodeValue(node);
                    }
                }
                
                this.nodes.forEach(node => this.updateNodeMesh(node));
                this.logCalculation('=== 계산 완료 ===');
            }

            topologicalSort() {
                const visited = new Set();
                const temp = new Set();
                const result = [];

                const visit = (node) => {
                    if (temp.has(node.id)) {
                        this.logCalculation(`순환 참조 감지: ${node.label}`);
                        return;
                    }
                    if (visited.has(node.id)) return;

                    temp.add(node.id);
                    const inputs = this.getNodeInputs(node);
                    inputs.forEach(link => visit(link.source));
                    temp.delete(node.id);
                    visited.add(node.id);
                    result.push(node);
                };

                this.nodes.forEach(node => {
                    if (!visited.has(node.id)) {
                        visit(node);
                    }
                });

                return result;
            }

            calculateNodeValue(node) {
                try {
                    const inputs = this.getNodeInputs(node);
                    
                    if (node.formula && node.formula.trim()) {
                        const scope = {};
                        const variables = [];
                        
                        inputs.forEach((link, index) => {
                            const varName = String.fromCharCode(97 + index);
                            scope[varName] = link.source.value * link.weight;
                            variables.push(`${varName}=${scope[varName].toFixed(3)}`);
                        });

                        try {
                            const result = math.evaluate(node.formula, scope);
                            node.value = result;
                            this.logCalculation(`${node.label}: ${node.formula} = ${result.toFixed(3)} (${variables.join(', ')})`);
                        } catch (error) {
                            this.logCalculation(`${node.label}: 수식 오류 - ${error.message}`);
                            node.value = 0;
                        }
                    } else {
                        let sum = 0;
                        const terms = [];
                        
                        inputs.forEach(link => {
                            const term = link.source.value * link.weight;
                            sum += term;
                            terms.push(`${link.source.value.toFixed(2)}*${link.weight.toFixed(2)}`);
                        });
                        
                        node.value = sum;
                        if (terms.length > 0) {
                            this.logCalculation(`${node.label}: ${terms.join(' + ')} = ${sum.toFixed(3)}`);
                        }
                    }
                } catch (error) {
                    this.logCalculation(`${node.label}: 계산 오류 - ${error.message}`);
                    node.value = 0;
                }
            }

            logCalculation(message) {
                const logDiv = document.getElementById('calculationLog');
                logDiv.innerHTML += message + '\n';
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            deleteNode(node) {    
                if (node.mesh) {
                    this.nodeGroup.remove(node.mesh);
                }
                if (node.textSprite) {
                    this.nodeGroup.remove(node.textSprite);
                }

                const connectedLinks = this.links.filter(link => 
                    link.source === node || link.target === node
                );
                
                connectedLinks.forEach(link => this.deleteLink(link));
                this.nodes = this.nodes.filter(n => n !== node);
                
                if (this.selectedNode === node) {
                    this.selectedNode = null;
                    this.updateSelectedNodeInfo();
                }

                if (this.autoLayoutEnabled) {
                    this.applyAutoLayout();
                }
            }

            deleteLink(link) {
                if (link.mesh) {
                    this.linkGroup.remove(link.mesh);
                }
                if (link.arrow) {
                    this.linkGroup.remove(link.arrow);
                }
                this.links = this.links.filter(l => l !== link);
            }

            sphereLayout() {
                const radius = 80;
                this.nodes.forEach((node, index) => {
                    const phi = Math.acos(-1 + (2 * index) / this.nodes.length);
                    const theta = Math.sqrt(this.nodes.length * Math.PI) * phi;
                    
                    node.position.set(
                        radius * Math.cos(theta) * Math.sin(phi),
                        radius * Math.cos(phi),
                        radius * Math.sin(theta) * Math.sin(phi)
                    );
                    this.updateNodeMesh(node);
                });
                this.links.forEach(link => this.updateLinkMesh(link));
            }

            render() {
                this.controls.update();
                
                if (this.autoRotateEnabled) {
                    this.nodeGroup.rotation.y += 0.005;
                    this.linkGroup.rotation.y += 0.005;
                }

                this.renderer.render(this.scene, this.camera);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.render();
            }
        }

        // Global instance
        let graph;

        // Initialize
        window.onload = function() {
            graph = new NetworkGraph3D();
        };

        // Global functions
        function addNode() {
            graph.selectedNode = null;
            showNodeModal();
        }

        function connectMode() {
            const btn = document.getElementById('connectBtn');
            if (graph.connectingMode) {
                graph.cancelConnecting();
            } else {
                graph.connectingMode = true;
                graph.connectingFrom = null;
                document.body.style.cursor = 'crosshair';
                btn.classList.add('active');
                graph.logCalculation('연결 모드 활성화 - 두 노드를 순서대로 클릭하세요');
            }
        }

        function calculateValues() {
            document.getElementById('calculationLog').innerHTML = '';
            graph.calculateValues();
        }

        function autoLayout() {
            graph.applyAutoLayout();
        }

        function resetGraph() {
            if (confirm('모든 데이터를 초기화하시겠습니까?')) {
                graph.nodeGroup.clear();
                graph.linkGroup.clear();
                
                graph.nodes = [];
                graph.links = [];
                graph.nodeIdCounter = 0;
                graph.selectedNode = null;
                
                graph.createSampleData();
                graph.updateSelectedNodeInfo();
                document.getElementById('calculationLog').innerHTML = '';
            }
        }

        function sphereLayout() {
            graph.sphereLayout();
        }

        function autoRotate() {
            const btn = document.getElementById('autoRotateBtn');
            graph.autoRotateEnabled = !graph.autoRotateEnabled;
            if (graph.autoRotateEnabled) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        // 저장/불러오기 기능
        function saveGraph() {
            try {
                const data = graph.exportData();
                const jsonString = JSON.stringify(data, null, 2);
                
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `network_graph_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                URL.revokeObjectURL(url);
                graph.logCalculation('그래프를 성공적으로 저장했습니다.');
            } catch (error) {
                graph.logCalculation(`저장 오류: ${error.message}`);
                alert('저장 중 오류가 발생했습니다: ' + error.message);
            }
        }

        function loadGraph(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (graph.importData(data)) {
                        alert('그래프를 성공적으로 불러왔습니다.');
                    } else {
                        alert('그래프 불러오기에 실패했습니다.');
                    }
                } catch (error) {
                    graph.logCalculation(`파일 읽기 오류: ${error.message}`);
                    alert('파일 형식이 올바르지 않습니다: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input
            input.value = '';
        }

        function exportToImage() {
            try {
                const canvas = graph.renderer.domElement;
                const link = document.createElement('a');
                link.download = `network_graph_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                graph.logCalculation('이미지를 성공적으로 저장했습니다.');
            } catch (error) {
                graph.logCalculation(`이미지 저장 오류: ${error.message}`);
                alert('이미지 저장 중 오류가 발생했습니다: ' + error.message);
            }
        }

        function editSelectedNode() {
            if (graph.selectedNode) {
                showNodeModal();
            }
        }

        function showNodeModal() {
            const node = graph.selectedNode;
            
            document.getElementById('nodeLabel').value = node ? node.label : '';
            document.getElementById('nodeValue').value = node ? node.value : 0;
            document.getElementById('nodeType').value = node ? node.type : 'input';
            document.getElementById('nodeFormula').value = node ? node.formula : '';
            
            if (node) {
                document.getElementById('nodeX').value = Math.round(node.position.x);
                document.getElementById('nodeY').value = Math.round(node.position.y);
                document.getElementById('nodeZ').value = Math.round(node.position.z);
            } else {
                document.getElementById('nodeX').value = 0;
                document.getElementById('nodeY').value = 0;
                document.getElementById('nodeZ').value = 0;
            }
            
            onNodeTypeChange();
            updateAvailableVariables();
            document.getElementById('nodeModal').style.display = 'block';
        }

        function onNodeTypeChange() {
            const type = document.getElementById('nodeType').value;
            const inputDiv = document.getElementById('inputValueDiv');
            const formulaDiv = document.getElementById('formulaDiv');
            
            if (type === 'input') {
                inputDiv.style.display = 'block';
                formulaDiv.style.display = 'none';
            } else {
                inputDiv.style.display = 'none';
                formulaDiv.style.display = 'block';
            }
        }

        function updateAvailableVariables() {
            const variablesDiv = document.getElementById('availableVariables');
            
            if (graph.selectedNode) {
                const inputs = graph.getNodeInputs(graph.selectedNode);
                let html = '';
                
                inputs.forEach((link, index) => {
                    const varName = String.fromCharCode(97 + index);
                    html += `<div class="node-item">${varName} = ${link.source.label} (${link.source.value.toFixed(3)})</div>`;
                });
                
                variablesDiv.innerHTML = html || '연결된 입력이 없습니다';
            } else {
                variablesDiv.innerHTML = '새 노드에는 변수가 없습니다';
            }
        }

        function saveNode() {
            const label = document.getElementById('nodeLabel').value;
            const value = parseFloat(document.getElementById('nodeValue').value) || 0;
            const type = document.getElementById('nodeType').value;
            const formula = document.getElementById('nodeFormula').value;

            if (graph.selectedNode) {
                graph.selectedNode.label = label;
                graph.selectedNode.value = value;
                graph.selectedNode.type = type;
                graph.selectedNode.formula = formula;
                graph.updateNodeMesh(graph.selectedNode);
            } else {
                graph.addNodeData(label, value, type, formula);
            }

            graph.updateSelectedNodeInfo();
            closeModal();
        }

        function deleteCurrentNode() {
            if (graph.selectedNode && confirm('이 노드를 삭제하시겠습니까?')) {
                graph.deleteNode(graph.selectedNode);
                closeModal();
            }
        }

        function deleteCurrentLink() {
            if (graph.selectedLink && confirm('이 연결을 삭제하시겠습니까?')) {
                graph.deleteLink(graph.selectedLink);
                closeModal();
            }
        }

        function saveLink() {
            const weight = parseFloat(document.getElementById('linkWeight').value) || 1;
            
            if (graph.selectedLink) {
                graph.selectedLink.weight = weight;
                graph.updateLinkMesh(graph.selectedLink);
            }
            
            closeModal();
        }

        function closeModal() {
            document.getElementById('nodeModal').style.display = 'none';
            document.getElementById('linkModal').style.display = 'none';
        }

        window.onclick = function(event) {
            const nodeModal = document.getElementById('nodeModal');
            const linkModal = document.getElementById('linkModal');
            if (event.target === nodeModal) {
                nodeModal.style.display = 'none';
            }
            if (event.target === linkModal) {
                linkModal.style.display = 'none';
            }
        }
    </script>
</body>
</html>
